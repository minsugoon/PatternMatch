<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pattern Match: Trinity Modes</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        :root {
            --bg-color: #f5f5f7;
            --primary: #1E88E5;
            --danger: #E53935;
            --success: #43A047;
            --warning: #FDD835;
            --text: #333;
        }

        body {
            font-family: 'Pretendard', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- 상단 UI --- */
        #top-bar {
            width: 100%;
            background: white;
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        /* 타이머 바 */
        #timer-container {
            width: 90%;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #timer-progress {
            width: 100%;
            height: 100%;
            background: var(--success);
            transition: width 0.1s linear, background 0.3s;
        }

        /* 점수 및 정보 표시 */
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 90%;
            font-weight: 700;
            color: #444;
            font-size: 1.1rem;
        }
        .mode-badge {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: #333;
            color: white;
        }

        /* 모드 선택 버튼 */
        .mode-selector {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }
        .mode-btn {
            border: none;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            background: #e0e0e0;
            color: #666;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }
        .mode-btn span { font-size: 0.7rem; font-weight: 400; margin-top: 2px; }
        .mode-btn.active {
            background: #333;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .mode-btn.active span { color: #ccc; }

        /* --- 게임 영역 --- */
        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 450px;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }

        canvas {
            border-radius: 16px;
            touch-action: none;
        }

        #grid-canvas {
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }

        #target-area {
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid rgba(0,0,0,0.05);
            backdrop-filter: blur(10px);
        }

        .label {
            font-size: 0.9rem;
            color: #555;
            font-weight: 700;
            margin-bottom: 5px;
            width: 100%;
            text-align: left;
            padding-left: 10px;
        }

        /* 애니메이션 */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        .shake { animation: shake 0.3s; }

        /* 게임 오버 모달 */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        #result-modal {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            width: 80%;
            max-width: 300px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: pop 0.3s ease-out;
        }
        @keyframes pop { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .modal-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 10px; color: #333; }
        .modal-score { font-size: 2.5rem; font-weight: 900; color: var(--primary); margin: 20px 0; }
        .modal-desc { font-size: 1rem; color: #666; margin-bottom: 20px; }
        .restart-btn {
            background: #333; color: white; border: none; padding: 12px 24px;
            border-radius: 12px; font-size: 1rem; font-weight: bold; cursor: pointer;
            width: 100%;
        }

    </style>
</head>
<body>

    <div id="top-bar">
        <div id="timer-container"><div id="timer-progress"></div></div>
        <div class="game-info">
            <span class="mode-badge" id="mode-badge">3x3 Speed Blitz</span>
            <span id="score-display">Score: 0</span>
        </div>
        
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setGameMode(3)" id="btn-3">
                3x3 <span>Speed</span>
            </button>
            <button class="mode-btn" onclick="setGameMode(4)" id="btn-4">
                4x4 <span>Infinite</span>
            </button>
            <button class="mode-btn" onclick="setGameMode(5)" id="btn-5">
                5x5 <span>Survival</span>
            </button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="grid-canvas"></canvas>
        <div id="target-area">
            <div class="label" id="instruction-text">순서 상관없이 찾으세요!</div>
            <canvas id="target-canvas"></canvas>
        </div>
    </div>

    <div id="modal-overlay">
        <div id="result-modal">
            <div class="modal-title" id="res-title">GAME OVER</div>
            <div class="modal-desc" id="res-desc">최종 기록</div>
            <div class="modal-score" id="res-score">0</div>
            <button class="restart-btn" onclick="restartGame()">다시 도전</button>
        </div>
    </div>

<script>
    // --- 1. 설정 및 데이터 ---
    const COLORS = ["#E53935", "#1E88E5", "#43A047", "#FDD835", "#424242"];
    const DIRECTIONS = [0, 90, 180, 270]; 
    const SHAPE_COUNT = 13; // 8이하 별 제거됨 (5각별 제거)

    // 게임 상태
    let gridSize = 3;
    let tiles = [];
    let targets = [];
    let selectedIndices = [];
    let targetOrder = []; // 순서 저장용
    let currentStep = 0;
    
    // 점수 및 모드 관련
    let score = 0;
    let round = 1;
    let isGameOver = false;
    let gameMode = 'speed'; // speed(3x3), infinite(4x4), survival(5x5)

    // 타이머 변수
    let timeLeft = 0;
    let maxTime = 0;
    let lastTime = 0;
    let timerId = null;

    // 캔버스
    const gridCanvas = document.getElementById('grid-canvas');
    const targetCanvas = document.getElementById('target-canvas');
    const gCtx = gridCanvas.getContext('2d');
    const tCtx = targetCanvas.getContext('2d');
    
    // UI 요소
    const timerBar = document.getElementById('timer-progress');
    const scoreDisplay = document.getElementById('score-display');
    const modeBadge = document.getElementById('mode-badge');
    const instructionText = document.getElementById('instruction-text');
    const modal = document.getElementById('modal-overlay');

    // --- 2. 도형 그리기 엔진 (롤백 + Soft Star) ---
    function drawShape(ctx, shapeIdx, x, y, size, color, direction) {
        ctx.save();
        ctx.translate(x, y);
        const r = size / 2;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        
        switch(shapeIdx) {
            case 0: ctx.rect(-r, -r, size, size); break; 
            case 1: ctx.roundRect(-r, -r, size, size, size * 0.2); break; 
            case 2: { const c = r * 0.4; ctx.moveTo(-r + c, -r); ctx.lineTo(r - c, -r); ctx.lineTo(r, -r + c); ctx.lineTo(r, r - c); ctx.lineTo(r - c, r); ctx.lineTo(-r + c, r); ctx.lineTo(-r, r - c); ctx.lineTo(-r, -r + c); } break; 
            case 3: drawPolygon(ctx, 0, 0, r, 5); break; 
            case 4: drawPolygon(ctx, 0, 0, r, 6); break; 
            case 5: drawPolygon(ctx, 0, 0, r, 8); break; 
            case 6: drawPolygon(ctx, 0, 0, r, 10); break; 
            case 7: ctx.arc(0, 0, r, 0, Math.PI * 2); break; 
            // Soft Stars (8+)
            case 8:  drawPerfectSoftStar(ctx, 0, 0, 8,  r, r * 0.6);  break;
            case 9:  drawPerfectSoftStar(ctx, 0, 0, 10, r, r * 0.65); break;
            case 10: drawPerfectSoftStar(ctx, 0, 0, 12, r, r * 0.7);  break;
            case 11: drawPerfectSoftStar(ctx, 0, 0, 14, r, r * 0.72); break;
            case 12: drawPerfectSoftStar(ctx, 0, 0, 16, r, r * 0.75); break;
        }
        ctx.closePath();
        ctx.fill();

        // 내부 화살표
        ctx.rotate(direction * Math.PI / 180);
        ctx.fillStyle = "white";
        ctx.beginPath();
        const aS = size * 0.18;
        ctx.moveTo(0, -aS);
        ctx.lineTo(aS * 0.866, aS * 0.5);
        ctx.lineTo(-aS * 0.866, aS * 0.5);
        ctx.fill();
        ctx.restore();
    }

    function drawPolygon(ctx, x, y, r, s) {
        ctx.moveTo(x + r * Math.cos(-Math.PI/2), y + r * Math.sin(-Math.PI/2));
        for (let i = 1; i <= s; i++) ctx.lineTo(x + r * Math.cos(i * 2 * Math.PI / s - Math.PI/2), y + r * Math.sin(i * 2 * Math.PI / s - Math.PI/2));
    }

    function drawPerfectSoftStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3; 
        let step = Math.PI / spikes;
        const cornerRadius = outerRadius * 0.08; 
        ctx.beginPath();
        const startInnerX = cx + Math.cos(rot + step) * innerRadius;
        const startInnerY = cy + Math.sin(rot + step) * innerRadius;
        ctx.moveTo(startInnerX, startInnerY);
        for (let i = 0; i < spikes; i++) {
            let idx = (i + 1) % spikes; 
            let outerAngle = rot + (idx * 2 * step); 
            let innerAngle = rot + (idx * 2 * step) + step;
            let ox = cx + Math.cos(outerAngle) * outerRadius;
            let oy = cy + Math.sin(outerAngle) * outerRadius;
            let ix = cx + Math.cos(innerAngle) * innerRadius;
            let iy = cy + Math.sin(innerAngle) * innerRadius;
            ctx.arcTo(ox, oy, ix, iy, cornerRadius);
            ctx.lineTo(ix, iy); 
        }
        ctx.closePath();
    }

    function drawBadge(ctx, x, y, number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = "#E53935";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "white";
        ctx.font = "bold 12px Pretendard";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(number, 0, 1);
        ctx.restore();
    }

    class Tile {
        constructor(s, c, d) {
            this.shape = s; this.color = c; this.dir = d;
            this.id = `${s}-${c}-${d}`;
        }
    }

    // --- 3. 게임 모드 관리 ---

    function setGameMode(size) {
        gridSize = size;
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${size}`).classList.add('active');

        // 모드별 설정 초기화
        if (size === 3) {
            gameMode = 'speed';
            maxTime = 60; // 60초 고정
            modeBadge.innerText = "3x3 타자왕 (Speed Blitz)";
            modeBadge.style.background = "#1E88E5";
            instructionText.innerHTML = "순서 상관없이 3개를 빠르게 찾으세요!";
        } else if (size === 4) {
            gameMode = 'infinite';
            maxTime = 30; // 시작 30초, +5/-10
            modeBadge.innerText = "4x4 집중력 마스터 (Infinite)";
            modeBadge.style.background = "#FDD835";
            modeBadge.style.color = "#333";
            instructionText.innerHTML = "<span style='color:#E53935'>왼쪽부터 순서대로 (1→2→3)</span> 찾으세요! (시간 연장)";
        } else if (size === 5) {
            gameMode = 'survival';
            maxTime = 20; // 라운드당 20초
            modeBadge.innerText = "5x5 생존자 (Perfect Survival)";
            modeBadge.style.background = "#E53935";
            instructionText.innerHTML = "번호 순서대로 찾으세요. <span style='color:#E53935'>틀리면 즉시 종료!</span>";
        }

        restartGame();
    }

    function restartGame() {
        modal.style.display = 'none';
        isGameOver = false;
        score = 0;
        round = 1;
        timeLeft = maxTime;
        lastTime = Date.now();
        
        updateScoreDisplay();
        generateLevel();
        
        if (timerId) cancelAnimationFrame(timerId);
        gameLoop();
    }

    // --- 4. 게임 루프 & 타이머 ---

    function gameLoop() {
        if (isGameOver) return;

        const now = Date.now();
        const delta = (now - lastTime) / 1000;
        lastTime = now;

        timeLeft -= delta;

        // UI 업데이트
        // 4x4 모드는 시간이 maxTime보다 늘어날 수 있으므로 비율 계산 주의
        let pct = 0;
        if (gameMode === 'infinite') {
             // 4x4는 60초를 시각적 기준으로 잡되, 넘어가면 꽉 찬 상태 유지
             pct = Math.min((timeLeft / 60) * 100, 100); 
        } else {
             pct = (timeLeft / maxTime) * 100;
        }
        
        timerBar.style.width = `${Math.max(0, pct)}%`;
        
        // 색상 변경
        if (pct < 20) timerBar.style.background = "#E53935";
        else if (pct < 50) timerBar.style.background = "#FDD835";
        else timerBar.style.background = "#43A047";

        if (timeLeft <= 0) {
            endGame("시간 종료!");
            return;
        }

        timerId = requestAnimationFrame(gameLoop);
    }

    function updateScoreDisplay() {
        if (gameMode === 'survival') {
            scoreDisplay.innerText = `Round: ${round}`;
        } else {
            scoreDisplay.innerText = `Score: ${score}`;
        }
    }

    // --- 5. 레벨 생성 로직 ---

    function generateLevel() {
        selectedIndices = [];
        currentStep = 0;
        
        // 타겟 생성
        targets = [];
        while(targets.length < 3) {
            let t = getRandomTile();
            if(!targets.some(ex => ex.id === t.id)) targets.push(t);
        }

        // 모드별 순서 설정
        if (gameMode === 'speed') {
            targetOrder = null; // 순서 없음
        } else if (gameMode === 'infinite') {
            targetOrder = [0, 1, 2]; // 1->2->3 고정
        } else if (gameMode === 'survival') {
            targetOrder = [0, 1, 2].sort(() => Math.random() - 0.5); // 랜덤 순서
        }

        // 그리드 채우기 (오답 함정 로직 포함)
        tiles = [...targets];
        const totalCells = gridSize * gridSize;
        while(tiles.length < totalCells) {
            let filler;
            // 5x5는 어렵게 (방향 함정)
            if(gameMode === 'survival') {
                let base = targets[Math.floor(Math.random() * targets.length)];
                if(Math.random() > 0.4) {
                    let newDir = (base.dir + [90,180,270][Math.floor(Math.random()*3)]) % 360;
                    filler = new Tile(base.shape, base.color, newDir);
                } else filler = getRandomTile();
            } 
            // 4x4는 보통 (모양 함정)
            else if (gameMode === 'infinite') {
                let base = targets[Math.floor(Math.random() * targets.length)];
                if(Math.random() > 0.5) {
                    let newShape = Math.floor(Math.random() * SHAPE_COUNT);
                    while(newShape === base.shape) newShape = Math.floor(Math.random() * SHAPE_COUNT);
                    filler = new Tile(newShape, base.color, DIRECTIONS[Math.floor(Math.random()*4)]);
                } else filler = getRandomTile();
            } 
            else {
                filler = getRandomTile();
            }
            if(!tiles.some(t => t.id === filler.id)) tiles.push(filler);
        }
        tiles.sort(() => Math.random() - 0.5);

        drawGrid();
        drawTargets();
    }

    function getRandomTile() {
        const s = Math.floor(Math.random() * SHAPE_COUNT);
        const c = COLORS[Math.floor(Math.random() * COLORS.length)];
        const d = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
        return new Tile(s, c, d);
    }

    // --- 6. 입력 처리 (핵심) ---

    gridCanvas.addEventListener('pointerdown', (e) => {
        if(isGameOver) return;
        const rect = gridCanvas.getBoundingClientRect();
        const tileSize = parseInt(gridCanvas.style.width) / gridSize;
        const idx = Math.floor((e.clientY - rect.top) / tileSize) * gridSize + Math.floor((e.clientX - rect.left) / tileSize);
        if(idx >= 0 && idx < tiles.length) handleTileClick(idx);
    });

    function handleTileClick(idx) {
        if (selectedIndices.includes(idx)) return;

        const tile = tiles[idx];
        let isCorrect = false;

        // 모드별 정답 판정
        if (gameMode === 'speed') {
            // 3x3: 순서 무관, 타겟에 있기만 하면 됨
            isCorrect = targets.some(t => t.id === tile.id);
        } else {
            // 4x4, 5x5: 현재 순서(currentStep)에 맞는 타겟이어야 함
            const targetIdxToFind = targetOrder[currentStep];
            const targetToFind = targets[targetIdxToFind];
            if (targetToFind.id === tile.id) isCorrect = true;
        }

        if (isCorrect) {
            // 정답 처리
            selectedIndices.push(idx);
            if (gameMode !== 'speed') currentStep++; // 순서 진행
            
            drawGrid();

            // 라운드 클리어?
            if (selectedIndices.length === 3) {
                setTimeout(nextRound, 100);
            }
        } else {
            // 오답 처리
            handleMistake();
        }
    }

    function nextRound() {
        if (gameMode === 'speed') {
            score++; 
        } else if (gameMode === 'infinite') {
            score += 100; // 기본 점수
            timeLeft += 5; // 시간 보너스
            // 시각적 피드백 (시간 추가)
            timerBar.style.background = "#fff";
            setTimeout(() => timerBar.style.background = "#43A047", 100);
        } else if (gameMode === 'survival') {
            round++;
            timeLeft = maxTime; // 시간 초기화 (라운드제)
        }
        updateScoreDisplay();
        generateLevel();
    }

    function handleMistake() {
        // 화면 흔들림
        gridCanvas.classList.remove('shake');
        void gridCanvas.offsetWidth;
        gridCanvas.classList.add('shake');
        if(navigator.vibrate) navigator.vibrate(200);

        if (gameMode === 'speed') {
            // 3x3: 페널티 없음 (그냥 시간만 흐름)
        } else if (gameMode === 'infinite') {
            // 4x4: 시간 10초 차감
            timeLeft -= 10;
            // 시각적 피드백 (빨간 번쩍임)
            document.body.style.background = "#ffcdd2";
            setTimeout(() => document.body.style.background = "#f5f5f7", 100);
        } else if (gameMode === 'survival') {
            // 5x5: 즉시 사망
            endGame("잘못된 선택!");
        }
    }

    function endGame(reason) {
        isGameOver = true;
        document.getElementById('res-title').innerText = reason;
        
        let resultText = "";
        let finalValue = "";
        
        if (gameMode === 'speed') {
            resultText = "총 클리어 횟수";
            finalValue = `${score}회`;
        } else if (gameMode === 'infinite') {
            resultText = "최종 점수";
            finalValue = `${Math.floor(score + (Date.now() - lastTime)/100)}점`; // 단순 예시
            finalValue = `${score}점`;
        } else {
            resultText = "생존 라운드";
            finalValue = `${round}라운드`;
        }

        document.getElementById('res-desc').innerText = resultText;
        document.getElementById('res-score').innerText = finalValue;
        
        modal.style.display = 'flex';
    }

    // --- 그리기 헬퍼 ---
    function drawGrid() {
        const containerWidth = document.getElementById('game-container').clientWidth - 40;
        const tileSize = Math.floor(containerWidth / gridSize);
        const gap = 8;
        const totalSize = tileSize * gridSize + gap * (gridSize - 1);
        const dpr = window.devicePixelRatio || 1;
        
        gridCanvas.width = totalSize * dpr;
        gridCanvas.height = totalSize * dpr;
        gridCanvas.style.width = `${totalSize}px`;
        gridCanvas.style.height = `${totalSize}px`;
        gCtx.scale(dpr, dpr);
        gCtx.clearRect(0,0,totalSize,totalSize);

        tiles.forEach((tile, i) => {
            const col = i % gridSize;
            const row = Math.floor(i / gridSize);
            const x = col * (tileSize + gap) + tileSize / 2;
            const y = row * (tileSize + gap) + tileSize / 2;
            drawShape(gCtx, tile.shape, x, y, tileSize * 0.85, tile.color, tile.dir);

            if(selectedIndices.includes(i)) {
                gCtx.lineWidth = 4;
                gCtx.strokeStyle = "#2979FF";
                gCtx.beginPath();
                gCtx.roundRect(x-tileSize/2, y-tileSize/2, tileSize, tileSize, 12);
                gCtx.stroke();
                gCtx.fillStyle = "rgba(41, 121, 255, 0.2)";
                gCtx.fill();
            }
        });
    }

    function drawTargets() {
        const dpr = window.devicePixelRatio || 1;
        const w = document.getElementById('target-area').clientWidth;
        const h = 70;
        targetCanvas.width = w * dpr; targetCanvas.height = h * dpr;
        targetCanvas.style.width = `${w}px`; targetCanvas.style.height = `${h}px`;
        tCtx.scale(dpr, dpr);
        const gap = 20; const size = 60;
        let startX = (w - ((size * 3) + (gap * 2))) / 2 + size/2;
        
        targets.forEach((t, i) => {
            const cx = startX + i * (size + gap);
            const cy = h/2;
            drawShape(tCtx, t.shape, cx, cy, size * 0.8, t.color, t.dir);

            // 순서 뱃지
            if (gameMode === 'infinite') {
                drawBadge(tCtx, cx + size/3, cy - size/3, i + 1);
            } else if (gameMode === 'survival') {
                const orderNum = targetOrder.indexOf(i) + 1;
                drawBadge(tCtx, cx + size/3, cy - size/3, orderNum);
            }
        });
    }

    window.addEventListener('resize', () => { drawGrid(); drawTargets(); });
    // 초기 시작
    setGameMode(3); 

</script>
</body>
</html>
