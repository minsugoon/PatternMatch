<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pattern Match: Perfect Soft Stars</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        :root {
            --bg-color: #f5f5f7;
            --primary: #1E88E5;
            --danger: #E53935;
            --success: #43A047;
            --text: #333;
        }

        body {
            font-family: 'Pretendard', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* 타이머바 */
        #round-timer-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
        }
        #round-progress {
            width: 100%;
            height: 100%;
            background: var(--success);
            transition: width 1s linear;
        }

        header {
            margin-top: 24px;
            text-align: center;
            width: 100%;
        }

        h1 { margin: 0; font-size: 1.2rem; color: #444; font-weight: 700; }
        .info-text { font-size: 0.8rem; color: #666; margin-top: 4px; min-height: 1.2em;}
        .highlight { color: var(--danger); font-weight: bold; }
        
        .difficulty-btn-group {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 12px;
        }
        
        button {
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            background: #ddd;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button.active {
            background: #333;
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }

        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 450px;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }

        canvas {
            border-radius: 12px;
            touch-action: none;
        }

        #grid-canvas {
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }

        #target-area {
            background: rgba(255,255,255,0.7);
            padding: 15px;
            border-radius: 16px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }

        #combo-timer-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: var(--danger);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .label-group {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 8px;
        }
        .label { font-size: 0.85rem; color: #666; font-weight: 600; }
        .combo-text { font-size: 0.85rem; color: var(--danger); font-weight: 800; display: none; }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        .shake { animation: shake 0.3s; }

    </style>
</head>
<body>

    <div id="round-timer-bar"><div id="round-progress"></div></div>

    <header>
        <h1>Pattern Match</h1>
        <div class="info-text" id="rule-display"></div>
        <div class="difficulty-btn-group">
            <button onclick="setDifficulty(3)" id="btn-3">3x3</button>
            <button onclick="setDifficulty(4)" id="btn-4">4x4</button>
            <button onclick="setDifficulty(5)" id="btn-5">5x5</button>
        </div>
    </header>

    <div id="game-container">
        <canvas id="grid-canvas"></canvas>
        
        <div id="target-area">
            <div class="label-group">
                <span class="label">Target</span>
                <span class="combo-text" id="combo-alert">⚡ 5초 안에 완료!</span>
            </div>
            <canvas id="target-canvas"></canvas>
            <div id="combo-timer-overlay"></div>
        </div>
    </div>

<script>
    // --- 설정 및 데이터 ---
    const COLORS = ["#E53935", "#1E88E5", "#43A047", "#FDD835", "#424242"];
    const DIRECTIONS = [0, 90, 180, 270]; 
    const SHAPE_COUNT = 13; // 8이하 별 제거됨 (5각별 제거)

    // 게임 상태 변수
    let currentGridSize = 3;
    let tiles = [];
    let targets = [];
    let selectedIndices = [];
    let targetOrder = [];
    let currentStep = 0;

    // 타이머 변수
    let roundTimeLimit = 60;
    let roundTimeLeft = 60;
    let roundTimerId = null;

    let comboTimeLimit = 5000;
    let comboStartTime = 0;
    let comboTimerId = null;
    let isComboActive = false;

    const gridCanvas = document.getElementById('grid-canvas');
    const targetCanvas = document.getElementById('target-canvas');
    const gCtx = gridCanvas.getContext('2d');
    const tCtx = targetCanvas.getContext('2d');
    
    const roundProgressBar = document.getElementById('round-progress');
    const comboProgressBar = document.getElementById('combo-timer-overlay');
    const comboAlert = document.getElementById('combo-alert');
    const ruleDisplay = document.getElementById('rule-display');

    // --- 그리기 함수 ---
    function drawShape(ctx, shapeIdx, x, y, size, color, direction) {
        ctx.save();
        ctx.translate(x, y);
        const r = size / 2;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        
        switch(shapeIdx) {
            // --- 기본 도형 (각진 형태 - 롤백) ---
            case 0: ctx.rect(-r, -r, size, size); break; // 정사각형
            case 1: ctx.roundRect(-r, -r, size, size, size * 0.2); break; // 둥근 사각형
            case 2: { const c = r * 0.4; ctx.moveTo(-r + c, -r); ctx.lineTo(r - c, -r); ctx.lineTo(r, -r + c); ctx.lineTo(r, r - c); ctx.lineTo(r - c, r); ctx.lineTo(-r + c, r); ctx.lineTo(-r, r - c); ctx.lineTo(-r, -r + c); } break; // 깎인 사각형
            case 3: drawPolygon(ctx, 0, 0, r, 5); break; // 오각형
            case 4: drawPolygon(ctx, 0, 0, r, 6); break; // 육각형
            case 5: drawPolygon(ctx, 0, 0, r, 8); break; // 팔각형
            case 6: drawPolygon(ctx, 0, 0, r, 10); break; // 십각형
            case 7: ctx.arc(0, 0, r, 0, Math.PI * 2); break; // 원

            // --- 고각성 별 (완벽한 라운드 처리) ---
            // 8각성 이상만 사용 (5각별 제거)
            case 8:  drawPerfectSoftStar(ctx, 0, 0, 8,  r, r * 0.6);  break;
            case 9:  drawPerfectSoftStar(ctx, 0, 0, 10, r, r * 0.65); break;
            case 10: drawPerfectSoftStar(ctx, 0, 0, 12, r, r * 0.7);  break;
            case 11: drawPerfectSoftStar(ctx, 0, 0, 14, r, r * 0.72); break;
            case 12: drawPerfectSoftStar(ctx, 0, 0, 16, r, r * 0.75); break;
        }
        ctx.closePath();
        ctx.fill();

        // 내부 방향키 (뾰족한 삼각형)
        ctx.rotate(direction * Math.PI / 180);
        ctx.fillStyle = "white";
        ctx.beginPath();
        const aS = size * 0.18;
        ctx.moveTo(0, -aS);
        ctx.lineTo(aS * 0.866, aS * 0.5);
        ctx.lineTo(-aS * 0.866, aS * 0.5);
        ctx.fill();

        ctx.restore();
    }

    // 각진 다각형 그리기 (기본)
    function drawPolygon(ctx, x, y, r, s) {
        ctx.moveTo(x + r * Math.cos(-Math.PI/2), y + r * Math.sin(-Math.PI/2));
        for (let i = 1; i <= s; i++) {
            ctx.lineTo(x + r * Math.cos(i * 2 * Math.PI / s - Math.PI/2), y + r * Math.sin(i * 2 * Math.PI / s - Math.PI/2));
        }
    }

    // [핵심 수정] 완벽하게 부드러운 별 그리기
    // 시작점을 오목한 부분(Valley)으로 옮겨서 Top 부분이 뾰족해지는 문제 해결
    function drawPerfectSoftStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3; // Top 위치 (-90도)
        let step = Math.PI / spikes;
        const cornerRadius = outerRadius * 0.08; // 미세한 라운드

        ctx.beginPath();
        
        // **FIX: 시작점을 첫 번째 오목한 지점(Inner Point)으로 설정**
        // 이렇게 하면 Top 꼭짓점(Outer Point 0)을 그릴 때 곡선(arcTo)을 통해 진입하므로 부드러워짐
        const startInnerX = cx + Math.cos(rot + step) * innerRadius;
        const startInnerY = cy + Math.sin(rot + step) * innerRadius;
        ctx.moveTo(startInnerX, startInnerY);

        // 루프를 돌면서 Outer -> Inner 순서로 그리기
        // i=0일 때 Outer 1(첫번째 뾰족이 다음)을 그리는 것이 아니라, 
        // 로직상 순서대로 다음 Outer를 향해 감.
        // 여기선 (i+1)번째 Outer Point를 타겟으로 하여 루프를 돔.
        
        for (let i = 0; i < spikes; i++) {
            // 현재 Inner에서 다음 Outer로 향하는 라운드 처리
            // 타겟 인덱스: (i+1) % spikes -> 즉, 다음 Outer Point
            // (시작이 I0 이므로, 첫 타겟은 O1. 마지막에 O0(Top)을 그리며 닫힘)
            
            let idx = (i + 1) % spikes; // 1, 2, ..., spikes-1, 0
            
            // 각도 계산
            let outerAngle = rot + (idx * 2 * step); 
            let innerAngle = rot + (idx * 2 * step) + step;

            let ox = cx + Math.cos(outerAngle) * outerRadius;
            let oy = cy + Math.sin(outerAngle) * outerRadius;

            let ix = cx + Math.cos(innerAngle) * innerRadius;
            let iy = cy + Math.sin(innerAngle) * innerRadius;

            // Outer Point는 둥글게 (arcTo)
            ctx.arcTo(ox, oy, ix, iy, cornerRadius);
            // Inner Point로 직선 연결 (오목한 부분은 뾰족하게 유지하여 별 느낌 살림)
            ctx.lineTo(ix, iy); 
        }
        ctx.closePath();
    }


    // 번호 뱃지 그리기
    function drawBadge(ctx, x, y, number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = "#E53935";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "white";
        ctx.font = "bold 12px Pretendard";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(number, 0, 1);
        ctx.restore();
    }

    class Tile {
        constructor(s, c, d) {
            this.shape = s; this.color = c; this.dir = d;
            this.id = `${s}-${c}-${d}`;
        }
    }

    // --- 타이머 함수들 ---
    function startRoundTimer() {
        stopRoundTimer();
        roundTimeLeft = roundTimeLimit;
        updateRoundBar();
        roundTimerId = setInterval(() => {
            roundTimeLeft--;
            updateRoundBar();
            if(roundTimeLeft <= 0) {
                stopRoundTimer(); stopComboTimer();
                alert("⏰ 시간 초과! (Time Over)");
                generateLevel();
            }
        }, 1000);
    }
    function stopRoundTimer() { if(roundTimerId) clearInterval(roundTimerId); }
    function updateRoundBar() {
        const pct = (roundTimeLeft / roundTimeLimit) * 100;
        roundProgressBar.style.width = `${pct}%`;
        roundProgressBar.style.background = pct > 50 ? "#43A047" : (pct > 20 ? "#FB8C00" : "#E53935");
    }
    function startComboTimer() {
        if(isComboActive) return;
        isComboActive = true;
        comboStartTime = Date.now();
        comboAlert.style.display = "block"; 
        comboTimerId = setInterval(() => {
            const elapsed = Date.now() - comboStartTime;
            const remaining = comboTimeLimit - elapsed;
            const pct = (remaining / comboTimeLimit) * 100;
            comboProgressBar.style.width = `${pct}%`;
            if(remaining <= 0) failCombo();
        }, 50);
    }
    function stopComboTimer() {
        isComboActive = false;
        clearInterval(comboTimerId);
        comboProgressBar.style.width = "0%";
        comboAlert.style.display = "none";
    }
    function failCombo() {
        stopComboTimer();
        gridCanvas.classList.add('shake');
        setTimeout(() => gridCanvas.classList.remove('shake'), 500);
        selectedIndices = [];
        currentStep = 0;
        drawGrid();
        if(navigator.vibrate) navigator.vibrate(200);
    }

    // --- 게임 로직 ---

    function generateLevel() {
        stopRoundTimer(); stopComboTimer();
        
        selectedIndices = [];
        currentStep = 0;
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${currentGridSize}`).classList.add('active');

        const ruleText = {
            3: "순서 상관없이 3개를 찾으세요. (60초)",
            4: "<span class='highlight'>왼쪽부터 순서대로(1→2→3)</span> 찾으세요. (40초)",
            5: "Target에 표시된 <span class='highlight'>번호 순서대로</span> 찾으세요. (20초)"
        };
        ruleDisplay.innerHTML = ruleText[currentGridSize];
        
        targets = [];
        while(targets.length < 3) {
            let t = getRandomTile();
            if(!targets.some(ex => ex.id === t.id)) targets.push(t);
        }

        if (currentGridSize === 3) {
            targetOrder = null;
        } else if (currentGridSize === 4) {
            targetOrder = [0, 1, 2];
        } else if (currentGridSize === 5) {
            targetOrder = [0, 1, 2].sort(() => Math.random() - 0.5);
        }

        tiles = [...targets];
        const totalCells = currentGridSize * currentGridSize;
        while(tiles.length < totalCells) {
            let filler;
            if(currentGridSize === 5) {
                let base = targets[Math.floor(Math.random() * targets.length)];
                if(Math.random() > 0.4) {
                    let newDir = (base.dir + [90,180,270][Math.floor(Math.random()*3)]) % 360;
                    filler = new Tile(base.shape, base.color, newDir);
                } else filler = getRandomTile();
            } else if (currentGridSize === 4) {
                let base = targets[Math.floor(Math.random() * targets.length)];
                if(Math.random() > 0.5) {
                    let newShape = Math.floor(Math.random() * SHAPE_COUNT);
                    while(newShape === base.shape) newShape = Math.floor(Math.random() * SHAPE_COUNT);
                    filler = new Tile(newShape, base.color, DIRECTIONS[Math.floor(Math.random()*4)]);
                } else filler = getRandomTile();
            } else {
                filler = getRandomTile();
            }
            if(!tiles.some(t => t.id === filler.id)) tiles.push(filler);
        }
        tiles.sort(() => Math.random() - 0.5);

        drawGrid();
        drawTargets();
        startRoundTimer();
    }

    function getRandomTile() {
        const s = Math.floor(Math.random() * SHAPE_COUNT);
        const c = COLORS[Math.floor(Math.random() * COLORS.length)];
        const d = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
        return new Tile(s, c, d);
    }

    // --- Draw ---
    function drawGrid() {
        const containerWidth = document.getElementById('game-container').clientWidth - 40;
        const tileSize = Math.floor(containerWidth / currentGridSize);
        const gap = 8;
        const totalSize = tileSize * currentGridSize + gap * (currentGridSize - 1);
        const dpr = window.devicePixelRatio || 1;
        
        gridCanvas.width = totalSize * dpr;
        gridCanvas.height = totalSize * dpr;
        gridCanvas.style.width = `${totalSize}px`;
        gridCanvas.style.height = `${totalSize}px`;
        gCtx.scale(dpr, dpr);
        gCtx.clearRect(0,0,totalSize,totalSize);

        tiles.forEach((tile, i) => {
            const col = i % currentGridSize;
            const row = Math.floor(i / currentGridSize);
            const x = col * (tileSize + gap) + tileSize / 2;
            const y = row * (tileSize + gap) + tileSize / 2;
            drawShape(gCtx, tile.shape, x, y, tileSize * 0.85, tile.color, tile.dir);

            if(selectedIndices.includes(i)) {
                gCtx.lineWidth = 4;
                gCtx.strokeStyle = "#2979FF";
                gCtx.beginPath();
                gCtx.roundRect(x-tileSize/2, y-tileSize/2, tileSize, tileSize, 12);
                gCtx.stroke();
                gCtx.fillStyle = "rgba(41, 121, 255, 0.2)";
                gCtx.fill();
            }
        });
    }

    function drawTargets() {
        const dpr = window.devicePixelRatio || 1;
        const w = document.getElementById('target-area').clientWidth;
        const h = 70;
        targetCanvas.width = w * dpr; targetCanvas.height = h * dpr;
        targetCanvas.style.width = `${w}px`; targetCanvas.style.height = `${h}px`;
        tCtx.scale(dpr, dpr);
        const gap = 20; const size = 60;
        let startX = (w - ((size * 3) + (gap * 2))) / 2 + size/2;
        
        targets.forEach((t, i) => {
            const cx = startX + i * (size + gap);
            const cy = h/2;
            drawShape(tCtx, t.shape, cx, cy, size * 0.8, t.color, t.dir);

            if (currentGridSize === 4) {
                drawBadge(tCtx, cx + size/3, cy - size/3, i + 1);
            } else if (currentGridSize === 5) {
                const orderNum = targetOrder.indexOf(i) + 1;
                drawBadge(tCtx, cx + size/3, cy - size/3, orderNum);
            }
        });
    }

    // --- 입력 핸들링 ---
    gridCanvas.addEventListener('pointerdown', (e) => {
        const rect = gridCanvas.getBoundingClientRect();
        const tileSize = parseInt(gridCanvas.style.width) / currentGridSize;
        const idx = Math.floor((e.clientY - rect.top) / tileSize) * currentGridSize + Math.floor((e.clientX - rect.left) / tileSize);
        if(idx >= 0 && idx < tiles.length) handleTileClick(idx);
    });

    function handleTileClick(idx) {
        if (selectedIndices.includes(idx)) return;

        const tile = tiles[idx];
        let isValidClick = false;

        if (currentGridSize === 3) {
            isValidClick = targets.some(t => t.id === tile.id);
        } 
        else {
            const targetIdxToFind = targetOrder[currentStep];
            const targetToFind = targets[targetIdxToFind];
            if (targetToFind.id === tile.id) {
                isValidClick = true;
            } else {
                isValidClick = false; 
            }
        }

        if (isValidClick) {
            if (selectedIndices.length === 0) startComboTimer();

            selectedIndices.push(idx);
            
            if (currentGridSize >= 4) {
                currentStep++;
            }
            
            drawGrid();

            if (selectedIndices.length === 3) {
                stopComboTimer();
                setTimeout(() => {
                    if(navigator.vibrate) navigator.vibrate([50,50,50]);
                    generateLevel();
                }, 150);
            }
        } else {
            gridCanvas.classList.remove('shake');
            void gridCanvas.offsetWidth;
            gridCanvas.classList.add('shake');
            if(navigator.vibrate) navigator.vibrate(100);
        }
    }

    function setDifficulty(size) {
        currentGridSize = size;
        if (size === 3) roundTimeLimit = 60;
        else if (size === 4) roundTimeLimit = 40;
        else if (size === 5) roundTimeLimit = 20;
        generateLevel();
    }

    window.addEventListener('resize', () => { drawGrid(); drawTargets(); });
    setDifficulty(3);

</script>
</body>
</html>
